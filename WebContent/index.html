<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Data Mapper</title>
    <script src="assets/lib/d3/d3.js"></script>
    <script src="assets/lib/jQuery/jquery-3.1.0.js"></script>

    <script src="assets/lib/jquery-ui-1.12.0.custom/jquery-ui.js"></script>

    <script src="assets/lib/underscore/underscore_1.8.3.js" type="text/javascript"></script>
    <script src="assets/lib/backbone/backbone_1.3.3.js" type="text/javascript"></script>
    <script src="assets/fileHandler.js"></script>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/context-menu.css">
    <link rel="stylesheet" href="assets/css/diagram-tool-bar.css">


</head>

<body>


<div id="right-click-menu">
    <input type="file" class="file-select input" id="input-file-select" name="input-select[]"
           accept="application/json"/>
    <ul class='custom-menu' id="container-menu">
        <li data-action="load">Load Schema</li>
        <li data-action="clear">Clear container</li>
    </ul>
</div>


<div id="op-panel">
    <button id="concat-op-btn">Add concat operator <br> 2 to 1</button>
    <button id="split-op-btn">Add split operator <br> 1 to 3</button>
</div>

<div id="canvas-container">
    <svg id="canvas" class="canvas" width="1800" height="500">
        <g id="input-container" transform="translate(40,40)" class="tree-container container">

            <g id="input-container-fo" class="container-fo">
                <rect class="container-title-outline" id="input-container-title-outline" height="20" fill="#D3DA7B"
                      stroke="black"></rect>
                <text class="container-title" id="input-container-title" font-weight="bold">Input</text>
                <rect class="container-outline" id="input-container-outline" height="10" fill="none"
                      stroke="black"></rect>
            </g>
        </g>


        <g id="output-container" transform="translate(1300,40)" class="tree-container container">
            <g id="output-container-fo" class="container-fo">
                <rect class="container-title-outline" id="output-container-title-outline" height="20" fill="#FCE0D3"
                      stroke="black"></rect>
                <text class="container-title" id="output-container-title" font-weight="bold">Output</text>
                <rect class="container-outline" id="output-container-outline" height="10" fill="none"
                      stroke="black"></rect>
            </g>

        </g>

    </svg>
    <div id="tool-palette">

    </div>
</div>
<button onclick="showMappings()">showMappings</button>


<script>

    var DataMapper = {
        //the editor = svg
        Canvas: d3.select("#canvas"),
        //a Backbone collection of all the operators in the app
        Operators: {},
        // Backbone view corresponding to Input/Output container
        // the model contains the loaded schema as a JSON object and a collection of nodes
        InputView: {},
        OutputView: {},
        //all the 'lines' drawn in the application
        //each connector contains information on sourceNode, targetNode, sourceContainer, targetContainer and the d3 line object
        Connectors: {},

        //Definitions
        Models: {},
        Collections: {},
        Views: {}
    };
</script>
<script src="assets/js/views.js"></script>
<script src="assets/js/models.js"></script>
<script src="assets/js/collections.js"></script>
<script src="assets/js/tool-palette/tool-view.js"></script>
<script src="assets/js/tool-palette/tool.js"></script>
<script src="assets/js/tool-palette/toolgroup-view.js"></script>
<script src="assets/js/tool-palette/toolgroup.js"></script>
<script src="assets/js/tool-palette/toolpalette-view.js"></script>
<script src="assets/js/tool-palette/toolpalette.js"></script>
<script>
    function showMappings() {
        var variableList = [], count = 0,
                nodeList = new DataMapper.Collections.NodeList(),
                inputAdjList = [],
                outputAdjList = [];
        [DataMapper.InputView.model, DataMapper.OutputView.model].map(function (model) {
            model.get('nodeCollection').models.map(function (node) {
                variableList.push({id: count, text: model.getPath(node.get('text')), type: node.get('textType')});
                node.set('id', count);
                nodeList.add(node);
                count++;
            });
        });
        DataMapper.Operators.models.map(function (model) {
            model.get('nodeCollection').models.map(function (node) {
                variableList.push({id: count, text: node.get('text'), type: node.get('textType')});
                node.set('id', count);
                count++;
                nodeList.add(node);
            });
        });
        DataMapper.Operators.models.map(function (model) {
            var inputs = [], outputs = [];
            model.get('nodeCollection').models.map(function (node) {
                var type = node.get('type');
                if (type === "output") {
                    var connector = DataMapper.Connectors.findFromTarget(node.get('node')) || null;
                    if (connector !== null) {
                        var opposite = connector.get('sourceNode'); //d3 node object
                        var oppositeNode = nodeList.getNodeFromDOMObject(opposite.node()); //backbone model
                        inputs.push([oppositeNode.get('id')]);
                    } else {
                        inputs.push([]);
                    }
                } else if (type === "input") {
                    var connectors = DataMapper.Connectors.findFromSource(node.get('node'));
                    var targets = [];
                    if (connectors.length > 0) {
                        connectors.map(function (connector) {
                            var opposite = connector.get('targetNode'); //d3 node object
                            var oppositeNode = nodeList.getNodeFromDOMObject(opposite.node()); //backbone model
                            targets.push(oppositeNode.get('id'));
                        });
                    }
                    outputs.push(targets);
                }
            });
            inputAdjList.push({operator: model, inputs: inputs});
            outputAdjList.push({operator: model, outputs: outputs});
        });
        console.log("variable list:");
        console.log(variableList);
        console.log("operators:");
        console.log(DataMapper.Operators.models);
        console.log("input adjacency list:");
        console.log(inputAdjList);
        console.log("output adjacency list:");
        console.log(outputAdjList);
//                console.log(DataMapper.Connectors.getMappings());
    }

    new DataMapper.Views.CanvasView();

    //Create tools
    var dataMapperLinkTool = new Tools.Models.Tool({
        id: "0",
        title: "Data Mapper Link",
        icon: "assets/images/tool-icons/sample-tool-icon"
    });
    var concatTool = new Tools.Models.Tool({
        id: "1",
        title: "Concat",
        icon: "assets/images/tool-icons/sample-tool-icon"
    });
    var splitTool = new Tools.Models.Tool({id: "2", title: "Split", icon: "assets/images/tool-icons/sample-tool-icon"});
    var andTool = new Tools.Models.Tool({id: "3", title: "And", icon: "assets/images/tool-icons/sample-tool-icon"});

    // Create tool groups
    var linkToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Link",
        toolGroupID: "link-tool-group"
    });
    linkToolGroup.toolCollection.add(dataMapperLinkTool);

    var commonToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Common",
        toolGroupID: "common-tool-group"
    });
    var arithmeticToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Arithmetic",
        toolGroupID: "arithmetic-tool-group"
    });
    var conditionalToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Conditional",
        toolGroupID: "conditional-tool-group"
    });
    var booleanToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Boolean",
        toolGroupID: "boolean-tool-group"
    });
    booleanToolGroup.toolCollection.add(andTool);

    var typeConversionToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "Type Conversion",
        toolGroupID: "typeConversion-tool-group"
    });
    var stringToolGroup = new Tools.Models.ToolGroup({
        toolGroupName: "String",
        toolGroupID: "string-tool-group"
    });
    stringToolGroup.toolCollection.add([concatTool, splitTool]);

    // Create tool palette
    var toolPalette = new Tools.Models.ToolPalatte();
    toolPalette.add([linkToolGroup, commonToolGroup, arithmeticToolGroup, conditionalToolGroup, booleanToolGroup, typeConversionToolGroup, stringToolGroup]);

    var paletteView = new Tools.Views.ToolPalatteView({collection: toolPalette});
    paletteView.render();

</script>


</body>

</html>