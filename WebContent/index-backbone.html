<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>Data Mapper tooling</title>
        <script src="assets/lib/d3/d3.js"></script>
        <script src="assets/lib/jQuery/jquery-3.1.0.js"></script>
        <script src="assets/lib/jquery-ui-1.12.0.custom/jquery-ui.js"></script>
        <script src="assets/lib/underscore/underscore_1.8.3.js" type="text/javascript"></script>
        <script src="assets/lib/backbone/backbone_1.3.3.js" type="text/javascript"></script>
        <script src="assets/fileHandler.js"></script>
        <link rel="stylesheet" href="assets/style.css">

        <style>
            .structure, .structure ul {
                list-style-type: none;
                text-indent: 5px;
            }

            .nested-group {
                border-bottom: 1px solid #c9c9c9;
                border-left: 1px solid #c9c9c9;
                width: max-content;
            }

            .leaf-node:active {
                opacity: 0.5;
            }

            .leaf-node:hover {
                opacity: 0.5;
            }
        </style>

    </head>

    <body>


        <div id="file-load">
            <div class="file-load-container" id="input-file-load-container">
                <button id="load-input-btn">Load input</button>
                <button id="clear-input-btn">Clear input</button>

                <div class="load-file" id="load-input">
                    <input type="file" class="file-select input" id="input-file-select" name="input-select[]" accept=".json"/>
                    <div class="file-drag input" id="input-file-drag">or drop files here</div>
                </div>

            </div>

            <div class="file-load-container" id="output-file-load-container">
                <button id="load-output-btn">Load output</button>
                <button id="clear-output-btn">Clear output</button>

                <div class="load-file" id="load-output">
                    <input type="file" class="file-select output" id="output-file-select" name="output-select[]" accept=".json"/>
                    <div class="file-drag output" id="output-file-drag">or drop files here</div>
                </div>

            </div>
        </div>

        <div id="op-panel">
            <button id="concat-op-btn">Add concat operator <br> 2 to 1</button>
        </div>

        <div id="canvas-container">
            <svg id="canvas" class="canvas" width="1800" height="500">
            <g id="input-container" transform="translate(0,0)" class="container">

            <g id="input-container-fo" class="container-fo">
            <rect class="container-title-outline" id="input-container-title-outline" height="20" fill="#77C1C0"
                  stroke="black"></rect>
            <text class="container-title" id="input-container-title" font-weight="bold">Input</text>
            <rect class="container-outline" id="input-container-outline" height="10" fill="none"
                  stroke="black"></rect>
            </g>
            </g>


            <g id="output-container" transform="translate(0,0)" class="container">
            <g id="output-container-fo" class="container-fo">
            <rect class="container-title-outline" id="output-container-title-outline" height="20" fill="#E59CA5"
                  stroke="black"></rect>
            <text class="container-title" id="output-container-title" font-weight="bold">Output</text>
            <rect class="container-outline" id="output-container-outline" height="10" fill="none"
                  stroke="black"></rect>
            </g>

            </g>

            </svg>

        </div>


        <script>
            var DataMapper = {
                Canvas: d3.select("#canvas"),
                Operators: {},
                InputContainer: {},
                OutputContainer: {},
                Models: {},
                Collections: {},
                Views: {},
                Templates: {}
            };
            DataMapper.Collections.Operators = Backbone.Collection.extend({
                model: DataMapper.Models.Operator
            });
            DataMapper.Views.LoadFileView = Backbone.View.extend({
                el: "#file-load",
                events: {
                    "change .file-select": "fileChange",
                    "dragenter .file-drag": "dragEnter",
                    "dragleave .file-drag": "dragLeave",
                    "dragover .file-drag": "dragOver",
                    "drop .file-drag": "drop",
                    "click #load-input-btn": 'slideInput',
                    "click #load-output-btn": "slideOutput",
                    "click #clear-input-btn": "clearInput",
                    "click #clear-output-btn": "clearOutput"
                },
                slideInput: function () {
                    $("#load-input").slideToggle();
                },
                slideOutput: function () {
                    $("#load-output").slideToggle();
                },
                clearInput: function () {
                    d3.select("#input-container").selectAll(".nested-group").remove();
                },
                clearOutput: function () {
                    d3.select("#output-container").selectAll(".nested-group").remove();
                },
                drop: function (e) {
                    this.dragLeave(e);
                    this.fileChange(e);
                },
                fileChange: function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    var files = e.target.files || e.dataTransfer.files;
                    if (d3.select(e.target).classed("input")) { //if the target is input
                        this.clearInput();
                        DataMapper.InputView.model.set('file', files[0]);
                        DataMapper.InputView.render();
                        this.slideInput();
                    } else if (d3.select(e.target).classed("output")) {
                        this.clearOutput();
                        DataMapper.OutputView.model.set('file', files[0]);
                        DataMapper.OutputView.render();
                        this.slideOutput();
                    }
                },
                dragEnter: function (e) {
                    d3.select(e.target).classed("file-drag-hover", true);
                },
                dragLeave: function (e) {
                    d3.select(e.target).classed("file-drag-hover", false);
                },
                dragOver: function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    d3.select(e.target).classed("file-drag-hover", true);
                }
            });
            DataMapper.Views.AnchorView = Backbone.View.extend({
                el: ".drag-head",
                initialize: function () {
                    this.model.drawArrow();
                }
            });
            DataMapper.Views.NodeView = Backbone.View.extend({
                el: ".node-element",
                initialize: function () {
                    this.model.drawNode();
                }
            });
            DataMapper.Views.OperatorView = Backbone.View.extend({
                el: "#op-panel",
                initialize: function () {
                    this.render();
                },
                render: function () {
                    this.model.drawContainer();
                }
            });
            DataMapper.Views.TreeContainerView = Backbone.View.extend({
                initialize: function () {
                    d3.select(this.el).call(this.model.dragContainer);
                    this.model.set('parent', this.el);
                    this.drawInitContainer();
                    //this.model.onchange updateContainer
                },
                render: function () {
                    this.model.drawContainer();
                },
                drawInitContainer: function () {
                    var parent = d3.select(this.el);
                    var height = this.model.get("nodeHeight") || this.model.nodeHeight;
                    var width = this.model.get("containerWidth") || this.model.containerWidth;

                    parent.select(".container-title-outline").attr("x", this.model.get('startX')).attr("y", this.model.get("startY") - height).attr("height", height).attr("width", width);
                    parent.select(".container-title").attr("x", this.model.get("startX")).attr("y", this.model.get("startY") - 5);
                    parent.select(".container-outline").attr("x", this.model.get('startX')).attr("y", this.model.get("startY")).attr("height", height).attr("width", width);
                    this.model.updateContainerHeight();
                }
            });
            DataMapper.Views.OperatorPanelView = Backbone.View.extend({
                el: "#op-panel",
                events: {
                    "click #concat-op-btn": "addConcatOp"
                },
                addConcatOp: function () {
                    var concatModel = new DataMapper.Models.Operator({title: "Concat", id: "concat" + new Date().getTime(), inputCount: 2, outputCount: 1});
                    var concatView = new DataMapper.Views.OperatorView({model: concatModel});
                    //console.log(concatModel);
//                    DataMapper.Operators.add([concatModel]);
                }
            });
            DataMapper.Views.CanvasView = Backbone.View.extend({
                el: "#canvas",
                params: {
                    inputStartX: 40,
                    inputStartY: 40,
                    outputStartX: 800,
                    outputStartY: 40
                },
                initialize: function () {
                    DataMapper.Operators = new DataMapper.Collections.Operators(); //initialize a collection
                    new DataMapper.Views.LoadFileView();
                    new DataMapper.Views.OperatorPanelView();
                    var inputModel = new DataMapper.Models.TreeContainer({type: "input", startX: this.params.inputStartX, startY: this.params.inputStartY});
                    DataMapper.InputView = new DataMapper.Views.TreeContainerView({el: "#input-container", model: inputModel});
                    var outputModel = new DataMapper.Models.TreeContainer({type: "output", startX: this.params.outputStartX, startY: this.params.outputStartY});
                    DataMapper.OutputView = new DataMapper.Views.TreeContainerView({el: "#output-container", model: outputModel});
//                    this.render();
                }
            });
            DataMapper.Models.Node = Backbone.Model.extend({//set parent, text, x,y, type,category
                defaults: {
                    parent: d3.select("#canvas"),
                    text: "",
                    x: 0,
                    y: 0,
                    width: 170,
                    height: 20,
                    type: "", //input or output or null
                    category: "leaf", //object, array or endType or operator,
                    dotPosition: [],
                    node: d3.select("#canvas")
                },
                initialize: function () {
                    if (this.get('type') === "input") {
                        this.set('dotPosition', [this.get('x') + this.get('width'), this.get('y') + this.get('height') / 2]);
                    } else if (this.get('type') === "output") {
                        this.set('dotPosition', [this.get('x'), this.get('y') + this.get('height') / 2]);
                    }
                },
                drawNode: function () {
                    //  function drawNode(container, parent, text, x, y, dotPosition, type) {
                    var model = this;
                    var height = this.get('height'),
                            width = this.get('width');
                    var parent1 = this.get('parent').append("g").attr("class", "node-element")
                            .attr("height", height)
                            .attr("width", width);
                    this.set('node', parent1);
                    if (this.get('category') === "operator") {
                        this.drawOutline();
                    }
                    parent1.append("text").attr("class", "node-element-text")
                            .attr("x", this.get('x') + 12)
                            .attr("y", this.get('y') + (3 * height / 4))
                            .text(this.get('text'));
                    if (this.get('dotPosition').length === 2) {
                        parent1.classed("leaf-node", true);
                        parent1.attr("type", this.get('type'));
                        var anchor = new DataMapper.Models.Anchor({parent: parent1, cx: this.get('dotPosition')[0], cy: this.get('dotPosition')[1], type: this.get('type')});
                        new DataMapper.Views.AnchorView({model: anchor});
//                        var arrowHead = drawArrow(parent1, this.get('dotPosition')[0],this.get('dotPosition')[1]);
//                        arrowHead.attr("type",this.get('type'));
                    } else {
                        parent1.classed("parent-node", true);
                    }

                    return parent1;
                },
                drawContainerNode: function (overhead) {
                    var obj = this.drawNode();
                    obj.select("text").attr("x", this.get("x") + 12 + overhead);
                    var model = this;
                    obj.append("svg:image")
                            .attr("x", this.get('x') + overhead)
                            .attr("y", this.get('y') + 4)
                            .attr("width", 11)
                            .attr("height", 11)
                            .attr("xlink:href", function () {
                                if (model.get('category') === "object") {
                                    return "assets/images/object-icon.png";
                                } else if (model.get('category') === "array") {
                                    return "assets/images/array-icon.png";
                                }
                                return "assets/images/leaf-icon.png";
                            });
                },
                drawOutline: function () {
                    this.get('node').append("rect")
                            .attr("x", this.get('x'))
                            .attr("y", this.get('y'))
                            .attr("width", this.get('width'))
                            .attr("height", this.get('height'))
                            .attr("stroke", "black")
                            .attr("fill", "none");
                }
            });
            DataMapper.Models.Anchor = Backbone.Model.extend({
                defaults: {
                    parent: DataMapper.Canvas,
                    cx: 0,
                    cy: 0,
                    width: 10,
                    height: 10,
                    points: "",
                    type: "input"
                },
                dragAnchor: d3.drag()
                        .on("start", function (d) {
                            var thisDragY = d3.select(this).attr("cy");
                            var thisDragX = d3.select(this).attr("cx");
                            var tempParent = d3.select(d3.select(this)["_groups"][0][0].parentNode);
                            dragHead2 = drawDragArrow(tempParent, thisDragX, thisDragY);
                            dragLine = tempParent.append("line").attr("class", "drag-line")
                                    .style("stroke", "black")
                                    .style("stroke-width", "2");
                            dragLine.attr("x1", thisDragX)
                                    .attr("x2", thisDragX)
                                    .attr("y1", thisDragY)
                                    .attr("y2", thisDragY);
                        })
                        .on("drag", function (d) {
                            coordinates = d3.mouse(this);
                            xx = coordinates[0];
                            yy = coordinates[1];
                            dragLine.attr("x2", xx).attr("y2", yy);
                            moveArrow(dragHead2, xx, yy);
                        })
                        .on("end", function (d) {
                            var sourceContainer = getParentContainer(d3.select(this));
                            target = detectDropNode(xx, yy, d3.select(this).attr("type"), sourceContainer);
                            if (target) {
                                var oppositeContainer = getParentContainer(target);
                                var dotx = Number(target.select(".drag-head").attr("cx")) + getTranslateX(oppositeContainer) - getTranslateX(sourceContainer);
                                var doty = Number(target.select(".drag-head").attr("cy")) + getTranslateY(oppositeContainer) - getTranslateY(sourceContainer);
                                dragLine
                                        .attr("x2", dotx)
                                        .attr("y2", doty)
                                        .attr("target-container", oppositeContainer.attr("id"));
                                dragHead2.remove();
                            } else {
                                //d3.select("#inputnode").text("");
                                dragLine.remove();
                                dragHead2.remove();
                            }
                        }),
                drawArrow: function () {
                    var newArrow = this.get('parent').append("polygon").attr("class", "drag-head");
                    this.moveArrow(newArrow, this.get('cx'), this.get('cy'));
                    newArrow.call(this.dragAnchor);
                },
                drawDragArrow: function (parent, cx, cy) {
                    var newArrow = parent.append("polygon").attr("class", "drag-head-2");
                    this.moveArrow(newArrow, cx, cy);
                    return newArrow;
                },
                moveArrow: function (arrow, cx, cy) {
                    arrow.attr("points", function () {
                        var p0 = [Number(cx) - 5, Number(cy) - 5],
                                p1 = [Number(cx) + 5, Number(cy)],
                                p2 = [Number(cx) - 5, Number(cy) + 5];
                        return p0[0] + "," + p0[1] + " " + p1[0] + "," + p1[1] + " " + p2[0] + "," + p2[1];
                    })
                            .attr("cx", cx)
                            .attr("cy", cy);
                }
            });
            DataMapper.Models.Operator = Backbone.Model.extend({
                title: "Operator",
                id: "id",
                inputCount: 0,
                outputCount: 0,
                defaults: {
                    x: 400,
                    y: 40,
                    leaves: [],
                    height: 20,
                    width: 120
                },
                dragContainer: //function () {
                        d3.drag()
                        .on("start", function () {
                            console.log("drag started");
                        })
                        .on("drag", function (d, i) {

                            this.x = this.x || 0;
                            this.y = this.y || 0;
                            this.x += d3.event.dx;
                            this.y += d3.event.dy;
                            d3.select(this).attr("transform", "translate(" + this.x + "," + this.y + ")");
//                            this.trial();
                            updateConnections(d3.event.dx, d3.event.dy, d3.select(this));
//                            resizeCanvas(d3.select(this));
                        })
                        .on("end", function () {
                            // resizeCanvas();
                        }),
                drawContainer: function () {
                    var canvas = DataMapper.Canvas;
                    var parent = canvas.append("g").attr("class", "operator container")
                            .attr("x", this.get('x')).attr("y", this.get('y'))
                            .attr("id", this.get('id'))
                            .attr("transform", "translate(0,0)");
                    var inputCount = this.get('inputCount'),
                            outputCount = this.get('outputCount');
                    var max = d3.max([inputCount, outputCount]);
                    var opTitleOutline = parent.append("rect")
                            .attr("width", 2 * this.get('width'))
                            .attr("height", 20) //height of the rect title=20
                            .attr("x", this.get('x'))
                            .attr("y", this.get('y'))
                            .attr("fill", "#C5E3FF")
                            .attr("stroke", "black");
                    var opTitle = parent.append("text")
                            .attr("font-weight", "bold")
                            .attr("x", this.get('x'))
                            .attr("y", this.get('y') + 15)
                            .text(this.get('title'));
                    this.set('y', this.get('y') + 20);
                    var opContainerOutline = parent.append("rect")
                            .attr("width", 2 * this.get('width'))
                            .attr("height", max * this.get('height'))
                            .attr("x", this.get('x'))
                            .attr("y", this.get('y'))
                            .attr("fill", "none")
                            .attr("stroke", "black");
                    var inputs = parent.append("g").attr("class", "op-inputs");
                    var outputs = parent.append("g").attr("class", "op-outputs");
                    if (inputCount !== 0) {
                        var tempHeight = this.get('height');
                        if (max !== inputCount) {
                            tempHeight = (max * this.get('height') / inputCount);
                        }
                        for (var i = 0; i < inputCount; i++) {
                            //parent, text, x,y,type,category

//                            var tempInput = inputs.append("g").attr("class", "node-element op-node leaf-node").attr("type", "output").attr("width", this.get('width')).attr("height", tempHeight);
                            var tempY = this.get('y') + i * tempHeight;
                            var node = new DataMapper.Models.Node({parent: inputs, text: "", x: this.get('x'), y: tempY, type: "output", category: "operator", height: tempHeight, width: this.get('width')});
                            node.drawNode();
                        }

                        this.set('x', this.get('width') + this.get('x'));
                    }
                    if (outputCount !== 0) {
                        var tempHeight = this.get('height');
                        if (max !== outputCount) {
                            tempHeight = (max * this.get('height') / outputCount);
                        }
                        for (var i = 0; i < outputCount; i++) {
//                            var tempOutput = outputs.append("g").attr("class", "node-element op-node leaf-node").attr("type", "input").attr("width", this.get('width')).attr("height", tempHeight);
                            var tempY = this.get('y') + i * tempHeight;
                            var node = new DataMapper.Models.Node({parent: outputs, text: "", x: this.get('x'), y: tempY, type: "input", category: "operator", height: tempHeight, width: this.get('width')});
                            node.drawNode();
                        }

                    }
                    parent.call(this.dragContainer);
                    console.log(canvas);
                },
                updateConnections: function (newX, newY, sourceContainer) {
                    sourceContainer.selectAll(".drag-line")
                            .attr("x2", function () {
                                return d3.select(this).attr("x2") - newX;
                            })
                            .attr("y2", function () {
                                return d3.select(this).attr("y2") - newY;
                            });
                    d3.select("#canvas").selectAll(".container").each(function () {

                        if (d3.select(this).attr("id") !== sourceContainer.attr("id")) {
                            var opposite = d3.select(this);
                            opposite.selectAll(".drag-line").each(function () {
                                if (d3.select(this).attr("target-container") === sourceContainer.attr("id")) {
                                    d3.select(this).attr("x2", function () {
                                        return Number(d3.select(this).attr("x2")) + Number(newX);
                                    })
                                            .attr("y2", function () {
                                                return Number(d3.select(this).attr("y2")) + Number(newY);
                                            });
                                }
                            });
                        }
                    });
                }
            });
            DataMapper.Models.TreeContainer = DataMapper.Models.Operator.extend({
                elementCount: 7,
                containerWidth: 300,
                nodeHeight: 20,
                file: '',
                type: "input",
                parent: d3.select("#canvas"),
                startX: 0,
                startY: 0,
                drawContainer: function () {
                    this.set('tempParent', this.get('parent'));
                    this.readFile();
                },
                readFile: function () {
                    console.log(this.get('startX'));
//                    this.set("type","bbb");
                    var model = this;
                    // display text
                    if (this.get('file').name.endsWith(".json") || this.get('file').type === "application/json") {

                        var reader = new FileReader();
                        var data;
                        reader.onload = function (e) {
                            //parseJSON
                            var text = e.target.result;
                            data = JSON.parse(text);
                            model.parseFile(data);
                        };
                        reader.readAsText(this.get('file'));
                    }
                },
                parseFile: function (data) {
                    var title = data.title || "Root";
                    var count = this.traverseJSONSchema(data, title, 0, 0, d3.select(this.get('tempParent')));
                    this.set('elementCount', count);
                    this.updateContainerHeight();
                },
                updateContainerHeight: function () {
                    var outline = d3.select(this.get('parent')).select(".container-outline");
                    var model = this;
                    outline.attr("height", function () {
                        var count = model.get('elementCount') || model.elementCount,
                                height = model.get('nodeHeight') || model.nodeHeight;
                        return (count) * height;
                    });
                },
                traverseJSONSchema: function (root, rootName, level, rank, resultPane) {
                    var height = this.nodeHeight,
                            width = this.containerWidth,
                            margin = width / 5,
                            x = this.get('startX'),
                            overhead = rank * margin,
                            y = this.get('startY') + level * height;
                    var tempParent = resultPane.append("g").attr("class", "nested-group");
                    if (root.type === "object") {
                        if (rootName !== "") {
                            var nodeText = rootName + ":" + root.type;
                            var node = new DataMapper.Models.Node({parent: tempParent, text: nodeText, x: x, y: y, type: this.get('type'), category: "object", height: height, width: width});
                            node.drawContainerNode(overhead);
                            this.updateMaxTextLength(nodeText);
                            rank++;
                            level++;
                        }
                        var nestedParent = tempParent.append("g").attr("class", "nested-group");
                        var keys = root.properties; //select PROPERTIES
                        for (var i = 0; i < Object.keys(keys).length; i++) {   //traverse through each PROPERTY of the object
                            var keyName = Object.keys(keys)[i];
                            var key = keys[keyName];
                            level = this.traverseJSONSchema(key, keyName, level, rank, tempParent);
                        }

                    } else if (root.type === "array") {
                        var keys = root.items; //select ITEMS
                        if (rootName !== "") {
                            var nodeText = rootName + ":" + root.type + "[" + keys.type + "]";
                            var node = new DataMapper.Models.Node({parent: tempParent, text: nodeText, x: x, y: y, type: this.get('type'), category: "array", height: height, width: width});
                            node.drawContainerNode(overhead);
                            this.updateMaxTextLength(nodeText);
                            rank++;
                            level++;
                        }

                        level = this.traverseJSONSchema(keys, "", level, rank, tempParent); //recurse through the items of array
                    } else if (["string", "integer", "number", "boolean"].indexOf(root.type) > -1) {    //when the type is a primitive
                        tempParent.classed("nested-group", false);
                        if (rootName !== "") {
                            var nodeText = rootName + ":" + root.type;
                            this.updateMaxTextLength(nodeText);
                            var node = new DataMapper.Models.Node({parent: tempParent, text: nodeText, x: x, y: y, type: this.get('type'), category: root.type, height: height, width: width});
                            node.drawContainerNode(overhead);
                            rank++;
                            level++;
                        }
                    }
                    return level;
                },
                updateMaxTextLength: function (t) {
//                    var m = t.node().getComputedTextLength();
//                    if (this.get('maxLength') < m) {
//                        this.set('maxLength', m)
//                    }
                }
            });
            new DataMapper.Views.CanvasView();



            function updateConnections(newX, newY, sourceContainer) {
                sourceContainer.selectAll(".drag-line")
                        .attr("x2", function () {
                            return d3.select(this).attr("x2") - newX;
                        })
                        .attr("y2", function () {
                            return d3.select(this).attr("y2") - newY;
                        });
                d3.select("#canvas").selectAll(".container").each(function () {

                    if (d3.select(this).attr("id") !== sourceContainer.attr("id")) {
                        var opposite = d3.select(this);
                        opposite.selectAll(".drag-line").each(function () {
                            if (d3.select(this).attr("target-container") === sourceContainer.attr("id")) {
                                d3.select(this).attr("x2", function () {
                                    return Number(d3.select(this).attr("x2")) + Number(newX);
                                })
                                        .attr("y2", function () {
                                            return Number(d3.select(this).attr("y2")) + Number(newY);
                                        });
                            }
                        });
                    }
                });
            }


            function getTranslation(transform) {
                // Create a dummy g for calculation purposes only. This will never
                // be appended to the DOM and will be discarded once this function
                // returns.
                var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                // Set the transform attribute to the provided string value.
                g.setAttributeNS(null, "transform", transform);
                // consolidate the SVGTransformList containing all transformations
                // to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
                // its SVGMatrix.
                var matrix = g.transform.baseVal.consolidate().matrix;
                // As per definition values e and f are the ones for the translation.
                return [matrix.e, matrix.f];
            }

            function getParentTransform(elementObject) { //parameter is an element in an object - inputs or outputs array
                var transform = d3.select(elementObject["_groups"][0][0].parentNode).attr("transform");
                return transform;
            }

            function getTranslateX(inputContainer) {
                return Number(getTranslation(inputContainer.attr("transform"))[0]);
            }

            function getTranslateY(inputContainer) {
                return Number(getTranslation(inputContainer.attr("transform"))[1]);
            }

            function getParentContainer(nodeElement) { //a recursive method to find g.container of an element
                if (nodeElement.classed("container")) {
                    return nodeElement;
                } else {
                    return getParentContainer(d3.select(nodeElement["_groups"][0][0].parentNode));
                }

            }

            function getDotposition(height, width, rank, margin, position) {
                var tempWidth = width - (rank * margin) + width * 7 / 8;
                var tempWidth2 = -rank * margin;
                var coordinates = [0, 0];
                coordinates[0] = (position === "RIGHT" ? tempWidth : tempWidth2);
                coordinates[1] = height / 2;
                return coordinates;
            }


       

            function drawDragArrow(parent, cx, cy) {
                var newArrow = parent.append("polygon").attr("class", "drag-head-2");
                moveArrow(newArrow, cx, cy);
                return newArrow;
            }

            function moveArrow(arrow, cx, cy) {
                arrow.attr("points", function () {
                    var p0 = [Number(cx) - 5, Number(cy) - 5],
                            p1 = [Number(cx) + 5, Number(cy)],
                            p2 = [Number(cx) - 5, Number(cy) + 5];
                    return p0[0] + "," + p0[1] + " " + p1[0] + "," + p1[1] + " " + p2[0] + "," + p2[1];
                })
                        .attr("cx", cx)
                        .attr("cy", cy);
            }



            function detectDropNode(xx, yy, type, sourceContainer) { //detect if a drop is near opposite type of drag-head
                var flag = false;
                d3.select("#canvas").selectAll(".leaf-node").each(function () { //assuming every leaf node has an anchor
                    if (!flag && d3.select(this).attr("type") !== type) {
                        var anchor = d3.select(this).select(".drag-head");
                        if (anchor !== null) {
                            var x = Number(anchor.attr("cx")) + getTranslateX(getParentContainer(d3.select(this))) - getTranslateX(sourceContainer);
                            var y = Number(anchor.attr("cy")) + getTranslateY(getParentContainer(d3.select(this))) - getTranslateY(sourceContainer);
                            if (pointInRect([xx, yy], x - 10, x + 10, y - 10, y + 10)) {
                                flag = d3.select(this);
                            }
                        }
                    }
                });
                return flag;
            }

            function pointInRect(point, x1, x2, y1, y2) { //determines if the point(array of coord) is bouded by the rectangle

                if (point[0] > x1 && point[0] < x2) {
                    //horizontally inside
                    if (point[1] > y1 && point[1] < y2) {
                        //vertically in
                        return true;
                    }
                }
                return false;
            }
        </script>


    </body>

</html>